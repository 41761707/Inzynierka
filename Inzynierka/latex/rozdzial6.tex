\chapter{Testy}
\thispagestyle{chapterBeginStyle}

\section{15}
\label{15Test}
    \subsection{Wprowadzenie}
        Piętnastka (fr. taquin), znana również w Polsce o nazwie \textit{przesuwanka}, w zapisie często podawana przy pomocy liczbowego
        odpowiednika (15) jest grą w formie specyficznej
        układanki, której powstanie datuje się na koniec XIX wieku. Składa się ona z 
        15 klocków oraz ramki, pierwotnie drewnianej. Ramka zaprojektowana została specjalnie z myślą
        o pozostawieniu jednego wolnego miejsca, aby móc w łatwy sposób przesuwać klocki sąsiadujące z miejscem 
        pustym. Celem gry jest ułożenie klocków w określony sposób, najcześciej w porządku rosnącym czytając 
        od lewej do prawej rzędami, z określonego stanu początkowego. Częstym zabiegiem stosowanym przez 
        twórców ów układanki jest konwersja liczb na części obrazka, aby zachęcić do gry młodszych odbiorców.

        \begin{figure}[H]
            \includegraphics[scale=0.5]{15_ułożona}
            \centering
            \caption{Wygląd układanki piętnastki wygenerowany przy pomocy zaimplementowanej w ramach pracy warstwy graficznej}
        \end{figure}

        \begin{figure}[H]
            \includegraphics[scale=0.5]{15_losowe}
            \centering
            \caption{Losowa rozwiązywalna permutacja układanki}
        \end{figure}

        \begin{figure}[H]
            \includegraphics[scale=0.15]{15_obrazkowa}
            \centering
            \caption{Piętnastka w formie obrazkowej. Źródło: \url{http://mypuzzlecollection.blogspot.com/2012/08/mc-escher-birds-fish-and-turtles.html}}
        \end{figure}

    \subsection{Teoria}
        W 1878 roku amerykański wynalazca gier i zagadek (między innymi zagadek szachowych) \textbf{Samuel Loyd} ze względu na swój fach 
        nie przeszedł obojętnie koło piętnastki proponując ułożenie układu rosnącego z pozycji, która 
        od początkowej różniła się pozycjami jedynie dwóch klocków numerowanych odpowiednio 14 i 15 \cite{FifteenLoydProblem}.
        Problem ów stał się na tyle popularny, iż została wyznaczona nagroda 1000 dolarów dla osoby, której udałoby się 
        znaleźć prawidłowe rozwiązanie przygotowanego przez Pana Samuela problemu.

        Niemożliwość ułożenia problemu przez bardzo długi czas doprowadziła do pierwszych poważniejszych rozważań 
        nad z pozoru trywialną łamigówką. Efektem prac matematyków było parę zaskakujących wniosków, które ostatecznie doprowadziły 
        do udowodnienia, iż wyżej przedstawiona łamigłówka jest nierozwiązywalna.
        \begin{lemma}
            Nie wszystkie ustawienia początkowe piętnastki są możliwe do rozwiązania.\cite{Fifteen}
        \end{lemma}
        Wynika to z faktu, iż dla układanki o parzystych rozmiarach (w tym przypadku układanka jest rozmiarów 4x4)
        rozwiązywalne są jedynie ułożenia o parzystej liczbie inwersji. Zagadka Pana Lyod'a jest 
        ustawieniem nieparzystym jeśli chodzi o inwersje. Prowadzi to do następującego wniosku:
        \begin{corollary}
            Istnieje $\frac{16!}{2}=10 461 394 944 000$ rozwiązywalnych ustawień. 
        \end{corollary}
        Dodatkową ciekawostką istotną z perspektywy wykonywanych testów jest maksymalna liczba posunięć, którą należy wykonać, 
        aby z rozwiązywalnego stanu osiągnąć wcześniej wyznaczony cel. Mianem \textbf{boskiej liczby} w odniesieniu do przesuwanki
        określą się największą liczbę posunięć, którą trzeba osiągnąć, aby rozwiązać najtrudniejsze ułożeniem początkowe. Przy pomocy matematyki 
        naukowcy odnaleźli najtrudniejsze ustawienia oraz obliczyli ów liczbę, co zaprezentowano w następującym lemacie:
        \begin{lemma}
            \textbf{Boska liczba} dla 15-elementowej przesuwanki wynosi \textbf{80}. \cite{80Moves}
        \end{lemma}
        Oznacza to, iż maksymalna liczba kroków algorytmu w żadnym wypadku nie powinna przekroczyć liczby 80.

        W trakcie poniżej opisanego testu sprawdzono plany przesuwania odpowiednich klocków, aby w jak najmniejszej możliwej liczbie ruchów
        otrzymać odpowiedni stan końcowy, przy okazji sprawdzono osiągnięcia czasowe jak i porównano otrzymane wyniki z popularnymi herustykiami 
        spersonalizowanymi pod rozwiązywanie ów układanki.

    \subsection{Przykład}
        Na podstawie następującego przykładu zostanie przedstawiony schemat rozwiązywania układanki przez algorytm:
        \begin{figure}[H]
            \label{15Przyklad}
            \includegraphics[scale=0.5]{15_przyklad}
            \centering
            \caption{Przykładowe startowe ułożenie przesuwanki}
        \end{figure}
        Algorytm buduje graf na podstawie jedynej zdefiniowanej w problemie akcji: przesuwania klocka. Robi to aż do momentu, gdy kafelki nie 
        będą ułożone w wczesniej zdefiniowanej kolejności. Dla zdefiniowanego powyżej przykładu w pierwszym kroku algorytm ma jedynie dwie możliwości 
        akcji aktywnych: zamiana klocka pustego z klockiem o numerze 3 lub klockiem o numerze 4. Na tej podstawie generuje kolejny poziom stanów. 
        Dla załączonego przykładu optymalnym rozwiązaniem jest odpowiednio zamiana pustego kafelka z kafelkami: 4,8,12, co zostało poprawnie 
        wyznaczone przez GRAPHPLAN. Poniżej przedstawiono zbiory akcji przeanalizowane przez algorytm w danym kroku jak i uproszczony graf planujący.

        \begin{figure}[H]
            \includegraphics[scale=0.4]{15_zbiory_akcji}
            \centering
            \caption{Akcje rozpatrywane przez algorytm w danym kroku}
        \end{figure}

        \begin{figure}[H]
            \includegraphics[scale=0.25]{15_graphplan}
            \centering
            \caption{Uproszczony graf planujący wygenerowany przez algorytm GRAPHPLAN przedstawiający stan każdego kafelka w danej warstwie. Węzły wypełnione 
            kolorem szarym obrazują stany, które są warunkami zajścia jak i efektami wykonywanej w danej warstwie akcji}
        \end{figure}

        \begin{figure}[H]
            \includegraphics[scale=0.5]{15_zamiany}
            \centering
            \caption{Obrazowe rozwiązanie na podstawie wygenerowanego grafu}
        \end{figure}

    \subsection{Szczegóły implementacyjne}
    Ważnym jest, aby przedstawić omawiany świat zgodnie z wytycznymi ustalonymi przez język \textbf{STRIPS}. Z tego powodu należy dokładnie okreslić 
    każdą istniejącą relację, które zostaną użytę do definiowania stanów, akcji, warunków początkowych oraz celów. 
    Pierwszą określoną relacją będzie dwuargumentowa relacja na, której opis został już zawarty w sekcji \ref{RozdzialAkcje}. W ramach,
    relacja $na(A,B)$ informuje algorytm o tym, iż klocek $A$ znajduje się na pozycji $B$. Następnie należy zdefiniować każdy z klocków. 
    Wykorzystano do tego jednoargumentowy predykat o nazwie $robot(R)$. Ze względu na to, iż stałe w prologu oznaczane są przy pomocy 
    małych liter każdy z klocków zawiera swoje odzworowanie w literach. Poniższa ilustracja przedstawia proces mapowania klocka na literę:

    \begin{figure}[H]
        \includegraphics[scale=0.25]{mapowanieKlockow}
        \centering
        \caption{Przyporządkowywanie klockom odpowiednich liter}
    \end{figure}

    W tym momencie należy wprowadzić rozróżnienie między klockiem a pozycją. Pozycje na planszy są stałe, numerowane rzędami od lewej do prawej,
    natomiast klocki mogą dynamicznie zmieniać swoją pozycję. Oznacza to tyle, iż numer klocka nie jest jednoznaczy z numerem pozycji. 
    Zrozumienie tego aspektu jest kluczowe, gdyż konwersja liczb na litery może prowadzić do zmieszania. 
    Dodatkowo należy zdefiniować relację $pusty(A)$, która informuje o tym, iż dana pozycja jest pusta, lub formalniej, jest okupowana 
    przez klocek o pustej sygnaturze. 

    Jedyną akcją aktywną zdefiniowaną w ramach przesuwanki jest akcja $idz(R,A,B)$, która przesuwa klocek $R$ z pozycji $A$ na pozycję $B$.
    Zgodnie z wprowadzeniem literowych oznaczeń klocków, akcję $idz(a,4,8)$ należy rozumieć jako przesunięcie klocka z numerem 1 z pozycji 4 
    na pozycję 8 (czyli pionowo o jedną pozycję w dół w ostatniej kolumnie). Dla każdej akcji należy zdefiniować jej warunki zajścia jak i efekty.
    W przypadku przesuwanki dokonano tego przy pomocy predykatów $preconditions/2$ oraz $effects/2$. Poniżej znajdują się ich implementacje 
    w języku programowania PROLOG:
    \begin{listing}[H]
        \begin{minted}{prolog}
            %preconditions(+Action,-States)
            preconditions(zostan(P),[P]).

            preconditions(idz(R,A,B), [na(R,A), pusty(B)]) :-
                robot(R), 
                adjacent(A,B).
        \end{minted}
    \caption{Implementacja predykatu preconditions/2}
    \end{listing}

    \begin{listing}[H]
        \begin{minted}{prolog}
            %effects(+Action,-States)
            effects(zostan(P),[P]).

            effects(idz(R,A,B), [na(R,B),pusty(A),~na(R,A),~pusty(B)]).
        \end{minted}
    \caption{Implementacja predykatu effects/2}
    \end{listing}

    Należy zwrócić uwagę na fakt, iż każdy z predykatów występuje w dwóch wersjach, jedna odpowiada za akcje podtrzymującą, w skład której 
    zawsze wchodzi jeden warunek zajścia oraz jeden efekt, oraz drugą, która odpowiada akcji aktywnej. W przypadku predykatu $preconditions/2$
    wykorzystaną relację $adjacent(A,B)$ która zachodzi w sytuacji, gdy pozycja $A$ sąsiaduje z pozycją $B$. Definicja sąsiedztwa jest identyczna 
    względem definicji wprowadzonej w \ref{DefinicjeSwiata}.

    \begin{listing}[H]
        \begin{minted}{prolog}
            %eadjacent(+From, +To)
            adjacent(A,B) :-
            n(A,B)
            ;
            n(B,A).
        \end{minted}
    \caption{Implementacja predykatu adjacent/2}
    \end{listing}
    
    Gdzie relacja $n(A,B)$ (n od angielskiego słowa neighbor, oznaczajacego sąsiada)
    przedstawia relację sąsiedztwa pozycji $A$ z pozycją $B$. Poniżej przedstawiono rozkład relacji 
    sąsiedztwa dla każdej z pozycji wchodzącej w skład przesuwanki.

    \begin{listing}[H]
        \begin{minted}{prolog}
            n(1,2). n(1,5).
            n(2,1). n(2,6). n(2,3).
            n(3,2). n(3,7). n(3,4).
            n(4,3). n(4,8).
            n(5,1). n(5,6). n(5,9).
            n(6,5). n(6,2). n(6,7). n(6,10).
            n(7,6). n(7,3). n(7,8). n(7,11).
            n(8,7). n(8,4). n(8,12).
            n(9,5). n(9,10). n(9,13).
            n(10,9). n(10,6). n(10,11). n(10,14).
            n(11,10). n(11,7). n(11,12). n(11,15).
            n(12,11). n(12,8). n(12,16). 
            n(13,9). n(13,14).
            n(14,13). n(14,10). n(14,15).
            n(15,14). n(15,11). n(15,16).
            n(16,15). n(16,12).
        \end{minted}
    \caption{Modelowanie relacji sąsiedztwa}
    \end{listing}
    Ostatnim aspektem, bez którego wykonywanie działań w opiswyanym świecie jest wprowadzenie stanów niespójnych, takich jak znajdowanie 
    się jednego bloczka na dwóch różnych pozycjach, bądź okupowanie jednej pozycji przez dwa różne klocki. Zostały to wykonane 
    przy pomocy predykatu $incosinstent/2$

    \begin{listing}[H]
        \begin{minted}{prolog}
            incosistent(+State1,+State2)
            incosistent(G,~G).
            incosistent(~G,G).
            incosistent(na(R,C1),na(R,C2)) :-
                C1 \== C2.
            
            inconsistent(na(_,C),pusty(C)).
            inconsistent(pusty(C),na(_,C)).
            inconsistent(na(R1,C),na(R2,C)) :-
                R1 \== R2.
        \end{minted}
    \caption{Implementacja predykatu incosistent/2}
    \end{listing}

    Po zdefiniowaniu powyższych predykatów, algorytm jest gotowy do generowania odpowiednich planów mających za zadanie ułożenie 
    układanki z dowolnej rozwiązywalnej pozycji początkowej.
    \subsection{Wyniki}

    \textbf{UWAGA:} Testy czasowe zaprezentowane w poniższych tabelach tyczą się osiągów samego algorytmu. Oznacza to, iż na czas wykonywania prób
    wyłączone zostały wszystkie poboczne funkcjonalności takie jak generowanie grafu, czy prezentowanie rozwiązania w formie graficznej. 
    Wykonanie poniższych badań w aplikacji może skutkować innymi wynikami, zwykle dłuższymi. Należy mieć to na uwadze przy potencjalnej 
    próbie odtwarzania badań.

    \begin{table}[H]
        \centering
         \begin{tabular}{||c | c | c|} 
         \hline
         Przesunięcia & Wnioskowania & Czas \\ [0.5ex] 
         \hline\hline
         1 &  &  \\ 
         \hline
         2 &  &  \\
         \hline
         3 &  &   \\
         \hline
         4 &  &   \\
         \hline
         5 &  &  \\
         \hline
         6 &  &  \\ 
         \hline
         7 &  &  \\
         \hline
         8 &  &   \\
         \hline
         9 &  &   \\
         \hline
         10 &  &  \\ [1ex]
         \hline
         \end{tabular}
    \end{table}
    Przez \textit{przesunięcia} należy rozumieć liczbę przesunięć, którą należy wykonać, aby wrócić do początkowego stanu. Dla początkowych wartości 
    wskazanych w tabelach zostało to wyznaczone poprzez ręczne przestawienie kafelków o daną liczbę przesunięc oraz zapisanie otrzymanego stanu 
    przy użyciu nomenklatury opisanej w rozdziale definiujacym świat. Zgodnie z powyższym, analizując przykład \ref{15Przyklad} łatwo zauważyc, 
    iż wymaganą liczbą przesunięc, potrzebną do powrotu do wyjściowego stanu przesuwanki jest liczba \textbf{3} (co w dalszej części udało się 
    udowodnić konstruując odpowiedni plan).


    \subsection{Młodsza siostra- ósemka}

    \subsection{Wyniki dla 8}
    \subsection{Wnioski}
\section{CargoBot}
\label{CargoBotTest}
    \subsection{Wprowadzenie}
        
    \subsection{Przykład}
    \subsection{Szczegóły implementacyjne}
    \subsection{Wyniki}
    \subsection{Wnioski}
\section{Przemieszczanie w przestrzeni}
    \subsection{Wprowadzenie}
    \subsection{Przykład}
    \subsection{Szczegóły implementacyjne}
    \subsection{Wyniki}
    \subsection{Wnioski}
\section{Wieża Hanoi}
    \subsection{Wprowadzenie}
    \subsection{Przykład}
    \subsection{Szczegóły implementacyjne}
    \subsection{Wyniki}
    \subsection{Wnioski}
\section{Osiem Hetmanów}
\label{OsiemHetmanowTest}
    \subsection{Wprowadzenie}
    \subsection{Przykład}
    \subsection{Szczegóły implementacyjne}
    \subsection{Wyniki}
    \subsection{Wnioski}