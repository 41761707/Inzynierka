\chapter{Testy}
\thispagestyle{chapterBeginStyle}

\section{15}
\label{15Test}
    \subsection{Wprowadzenie}
        Piętnastka (fr. taquin), znana również w Polsce o nazwie \textit{przesuwanka}, w zapisie często podawana przy pomocy liczbowego
        odpowiednika (15) jest grą w formie specyficznej
        układanki, której powstanie datuje się na koniec XIX wieku. Składa się ona z 
        15 klocków oraz ramki, pierwotnie drewnianej. Ramka zaprojektowana została specjalnie z myślą
        o pozostawieniu jednego wolnego miejsca, aby móc w łatwy sposób przesuwać klocki sąsiadujące z miejscem 
        pustym. Celem gry jest ułożenie klocków w określony sposób, najcześciej w porządku rosnącym czytając 
        od lewej do prawej rzędami, z określonego stanu początkowego. Częstym zabiegiem stosowanym przez 
        twórców ów układanki jest konwersja liczb na części obrazka, aby zachęcić do gry młodszych odbiorców.

        \begin{figure}[H]
            \includegraphics[scale=0.5]{15_ułożona}
            \centering
            \caption{Wygląd układanki piętnastki wygenerowany przy pomocy zaimplementowanej w ramach pracy warstwy graficznej}
        \end{figure}

        \begin{figure}[H]
            \includegraphics[scale=0.5]{15_losowe}
            \centering
            \caption{Losowa rozwiązywalna permutacja układanki}
        \end{figure}

        \begin{figure}[H]
            \includegraphics[scale=0.15]{15_obrazkowa}
            \centering
            \caption{Piętnastka w formie obrazkowej. Źródło: \url{http://mypuzzlecollection.blogspot.com/2012/08/mc-escher-birds-fish-and-turtles.html}}
        \end{figure}

    \subsection{Teoria}
        W 1878 roku amerykański wynalazca gier i zagadek (między innymi zagadek szachowych) \textbf{Samuel Loyd} ze względu na swój fach 
        nie przeszedł obojętnie koło piętnastki proponując ułożenie układu rosnącego z pozycji, która 
        od początkowej różniła się pozycjami jedynie dwóch klocków numerowanych odpowiednio 14 i 15 \cite{FifteenLoydProblem}.
        Problem ów stał się na tyle popularny, iż została wyznaczona nagroda 1000 dolarów dla osoby, której udałoby się 
        znaleźć prawidłowe rozwiązanie przygotowanego przez Pana Samuela problemu.

        Niemożliwość ułożenia problemu przez bardzo długi czas doprowadziła do pierwszych poważniejszych rozważań 
        nad z pozoru trywialną łamigówką. Efektem prac matematyków było parę zaskakujących wniosków, które ostatecznie doprowadziły 
        do udowodnienia, iż wyżej przedstawiona łamigłówka jest nierozwiązywalna.
        \begin{lemma}
            Nie wszystkie ustawienia początkowe piętnastki są możliwe do rozwiązania.\cite{Fifteen}
        \end{lemma}
        Wynika to z faktu, iż dla układanki o parzystych rozmiarach (w tym przypadku układanka jest rozmiarów 4x4)
        rozwiązywalne są jedynie ułożenia o parzystej liczbie inwersji. Zagadka Pana Lyod'a jest 
        ustawieniem nieparzystym jeśli chodzi o inwersje. Prowadzi to do następującego wniosku:
        \begin{corollary}
            Istnieje $\frac{16!}{2}=10 461 394 944 000$ rozwiązywalnych ustawień. 
        \end{corollary}
        Dodatkową ciekawostką istotną z perspektywy wykonywanych testów jest maksymalna liczba posunięć, którą należy wykonać, 
        aby z rozwiązywalnego stanu osiągnąć wcześniej wyznaczony cel. Mianem \textbf{boskiej liczby} w odniesieniu do przesuwanki
        określą się największą liczbę posunięć, którą trzeba osiągnąć, aby rozwiązać najtrudniejsze ułożeniem początkowe. Przy pomocy matematyki 
        naukowcy odnaleźli najtrudniejsze ustawienia oraz obliczyli ów liczbę, co zaprezentowano w następującym lemacie:
        \begin{lemma}
            \textbf{Boska liczba} dla 15-elementowej przesuwanki wynosi \textbf{80}. \cite{80Moves}
        \end{lemma}
        Oznacza to, iż maksymalna liczba kroków algorytmu w żadnym wypadku nie powinna przekroczyć liczby 80.

        W trakcie poniżej opisanego testu sprawdzono plany przesuwania odpowiednich klocków, aby w jak najmniejszej możliwej liczbie ruchów
        otrzymać odpowiedni stan końcowy, przy okazji sprawdzono osiągnięcia czasowe jak i porównano otrzymane wyniki z popularnymi herustykiami 
        spersonalizowanymi pod rozwiązywanie ów układanki.

    \subsection{Przykład}
        Na podstawie następującego przykładu zostanie przedstawiony schemat rozwiązywania układanki przez algorytm:
        \begin{figure}[H]
            \label{Przyklad15}
            \includegraphics[scale=0.5]{15_przyklad}
            \centering
            \caption{Przykładowe startowe ułożenie przesuwanki}
        \end{figure}
        Algorytm buduje graf na podstawie jedynej zdefiniowanej w problemie akcji: przesuwania klocka. Robi to aż do momentu, gdy kafelki nie 
        będą ułożone w wczesniej zdefiniowanej kolejności. Dla zdefiniowanego powyżej przykładu w pierwszym kroku algorytm ma jedynie dwie możliwości 
        akcji aktywnych: zamiana klocka pustego z klockiem o numerze 3 lub klockiem o numerze 4. Na tej podstawie generuje kolejny poziom stanów. 
        Dla załączonego przykładu optymalnym rozwiązaniem jest odpowiednio zamiana pustego kafelka z kafelkami: 4,8,12, co zostało poprawnie 
        wyznaczone przez GRAPHPLAN. Poniżej przedstawiono zbiory akcji przeanalizowane przez algorytm w danym kroku jak i uproszczony graf planujący.

        \begin{figure}[H]
            \includegraphics[scale=0.4]{15_zbiory_akcji}
            \centering
            \caption{Akcje rozpatrywane przez algorytm w danym kroku}
        \end{figure}

        \begin{figure}[H]
            \includegraphics[scale=0.25]{15_graphplan}
            \centering
            \caption{Uproszczony graf planujący wygenerowany przez algorytm GRAPHPLAN przedstawiający stan każdego kafelka w danej warstwie. Węzły wypełnione 
            kolorem szarym obrazują stany, które są warunkami zajścia jak i efektami wykonywanej w danej warstwie akcji}
        \end{figure}

        \begin{figure}[H]
            \includegraphics[scale=0.5]{15_zamiany}
            \centering
            \caption{Obrazowe rozwiązanie na podstawie wygenerowanego grafu}
        \end{figure}

    \subsection{Szczegóły implementacyjne}
    Ważnym jest, aby przedstawić omawiany świat zgodnie z wytycznymi ustalonymi przez język \textbf{STRIPS}. Z tego powodu należy dokładnie okreslić 
    każdą istniejącą relację, które zostaną użytę do definiowania stanów, akcji, warunków początkowych oraz celów. 
    Pierwszą określoną relacją będzie dwuargumentowa relacja na, której opis został już zawarty w sekcji \ref{RozdzialAkcje}. W ramach,
    relacja $na(A,B)$ informuje algorytm o tym, iż klocek $A$ znajduje się na pozycji $B$. Następnie należy zdefiniować każdy z klocków. 
    Wykorzystano do tego jednoargumentowy predykat o nazwie $robot(R)$. Ze względu na to, iż stałe w prologu oznaczane są przy pomocy 
    małych liter każdy z klocków zawiera swoje odzworowanie w literach. Poniższa ilustracja przedstawia proces mapowania klocka na literę:

    \begin{figure}[H]
        \includegraphics[scale=0.25]{mapowanieKlockow}
        \centering
        \caption{Przyporządkowywanie klockom odpowiednich liter}
    \end{figure}

    W tym momencie należy wprowadzić rozróżnienie między klockiem a pozycją. Pozycje na planszy są stałe, numerowane rzędami od lewej do prawej,
    natomiast klocki mogą dynamicznie zmieniać swoją pozycję. Oznacza to tyle, iż numer klocka nie jest jednoznaczy z numerem pozycji. 
    Zrozumienie tego aspektu jest kluczowe, gdyż konwersja liczb na litery może prowadzić do zmieszania. 
    Dodatkowo należy zdefiniować relację $pusty(A)$, która informuje o tym, iż dana pozycja jest pusta, lub formalniej, jest okupowana 
    przez klocek o pustej sygnaturze. 

    Jedyną akcją aktywną zdefiniowaną w ramach przesuwanki jest akcja $idz(R,A,B)$, która przesuwa klocek $R$ z pozycji $A$ na pozycję $B$.
    Zgodnie z wprowadzeniem literowych oznaczeń klocków, akcję $idz(a,4,8)$ należy rozumieć jako przesunięcie klocka z numerem 1 z pozycji 4 
    na pozycję 8 (czyli pionowo o jedną pozycję w dół w ostatniej kolumnie). Dla każdej akcji należy zdefiniować jej warunki zajścia jak i efekty.
    W przypadku przesuwanki dokonano tego przy pomocy predykatów $preconditions/2$ oraz $effects/2$. Poniżej znajdują się ich implementacje 
    w języku programowania PROLOG:
    \begin{listing}[H]
        \begin{minted}{prolog}
            %preconditions(+Action,-States)
            preconditions(zostan(P),[P]).

            preconditions(idz(R,A,B), [na(R,A), pusty(B)]) :-
                robot(R), 
                adjacent(A,B).
        \end{minted}
    \caption{Implementacja predykatu preconditions/2 dla przesuwanki}
    \end{listing}

    \begin{listing}[H]
        \begin{minted}{prolog}
            %effects(+Action,-States)
            effects(zostan(P),[P]).

            effects(idz(R,A,B), [na(R,B),pusty(A),~na(R,A),~pusty(B)]).
        \end{minted}
    \caption{Implementacja predykatu effects/2 dla przesuwanki}
    \end{listing}

    Należy zwrócić uwagę na fakt, iż każdy z predykatów występuje w dwóch wersjach, jedna odpowiada za akcje podtrzymującą, w skład której 
    zawsze wchodzi jeden warunek zajścia oraz jeden efekt, oraz drugą, która odpowiada akcji aktywnej. W przypadku predykatu $preconditions/2$
    wykorzystaną relację $adjacent(A,B)$ która zachodzi w sytuacji, gdy pozycja $A$ sąsiaduje z pozycją $B$. Definicja sąsiedztwa jest identyczna 
    względem definicji wprowadzonej w \ref{DefinicjeSwiata}.

    \begin{listing}[H]
        \begin{minted}{prolog}
            %eadjacent(+From, +To)
            adjacent(A,B) :-
            n(A,B)
            ;
            n(B,A).
        \end{minted}
    \caption{Implementacja predykatu adjacent/2}
    \end{listing}
    
    Gdzie relacja $n(A,B)$ (n od angielskiego słowa neighbor, oznaczajacego sąsiada)
    przedstawia relację sąsiedztwa pozycji $A$ z pozycją $B$. Poniżej przedstawiono rozkład relacji 
    sąsiedztwa dla każdej z pozycji wchodzącej w skład przesuwanki.

    \begin{listing}[H]
        \begin{minted}{prolog}
            n(1,2). n(1,5).
            n(2,1). n(2,6). n(2,3).
            n(3,2). n(3,7). n(3,4).
            n(4,3). n(4,8).
            n(5,1). n(5,6). n(5,9).
            n(6,5). n(6,2). n(6,7). n(6,10).
            n(7,6). n(7,3). n(7,8). n(7,11).
            n(8,7). n(8,4). n(8,12).
            n(9,5). n(9,10). n(9,13).
            n(10,9). n(10,6). n(10,11). n(10,14).
            n(11,10). n(11,7). n(11,12). n(11,15).
            n(12,11). n(12,8). n(12,16). 
            n(13,9). n(13,14).
            n(14,13). n(14,10). n(14,15).
            n(15,14). n(15,11). n(15,16).
            n(16,15). n(16,12).
        \end{minted}
    \caption{Modelowanie relacji sąsiedztwa}
    \end{listing}
    Ostatnim aspektem, bez którego wykonywanie działań w opiswyanym świecie jest wprowadzenie stanów niespójnych, takich jak znajdowanie 
    się jednego bloczka na dwóch różnych pozycjach, bądź okupowanie jednej pozycji przez dwa różne klocki. Zostały to wykonane 
    przy pomocy predykatu $incosinstent/2$

    \begin{listing}[H]
        \begin{minted}{prolog}
            inconsistent(+State1,+State2)
            inconsistent(G,~G).
            inconsistent(~G,G).
            inconsistent(na(R,C1),na(R,C2)) :-
                C1 \== C2.
            
            inconsistent(na(_,C),pusty(C)).
            inconsistent(pusty(C),na(_,C)).
            inconsistent(na(R1,C),na(R2,C)) :-
                R1 \== R2.
        \end{minted}
    \caption{Implementacja predykatu inconsistent/2}
    \end{listing}

    Po zdefiniowaniu powyższych predykatów, algorytm jest gotowy do generowania odpowiednich planów mających za zadanie ułożenie 
    układanki z dowolnej rozwiązywalnej pozycji początkowej.
    \subsection{Wyniki}

    \textbf{UWAGA:} Testy czasowe zaprezentowane w poniższych tabelach tyczą się osiągów samego algorytmu. Oznacza to, iż na czas wykonywania prób
    wyłączone zostały wszystkie poboczne funkcjonalności takie jak generowanie grafu, czy prezentowanie rozwiązania w formie graficznej. 
    Wykonanie poniższych badań w aplikacji może skutkować innymi wynikami, zwykle dłuższymi. Ponadto testy czasowe obarczone są nieprawidłowościami 
    związanymi z działaniem innych, równoległych procesów w trakcie uruchamiania programu. Należy mieć to na uwadze przy potencjalnej 
    próbie odtwarzania badań. \\
    W kodach źródłowych (patrz Dodatek~\ref{plytaCD}) w katalogu \texttt{sources} znajduje się plik o nazwie \texttt{15\_tests.txt}, w którym 
    przedstawione są dokładne stany początkowe, dla których algorytm został uruchomiony, całkowity plan wygenerowany przez algorytm oraz 
    liczbę wnioskowań jak i wykorzystany czas dla każdego z przypadków. Ze względów objętościowych, w niniejszej pracy zostaną zamieszczone 
    jedyne najważniejsze informacje.

    \begin{table}[H]
        \centering
         \begin{tabular}{||c | c | c | c | c | c |} 
         \hline
         Przesunięcia & Test1 & Test2 & Test3 & Test4 & Test5 \\ [0.5ex] 
         \hline\hline
         1 & 0.009 & 0.009 & --- & --- & --- \\ 
         \hline
         2 &  & 0.026 & --- & --- & --- \\
         \hline
         3 &  & 0.126 & --- & --- & --- \\
         \hline
         4 &  & 0.519 & --- & --- & --- \\
         \hline
         5 &  & 1.214 & --- & --- & --- \\
         \hline
         6 &  & 1.847 & --- & --- & ---\\ 
         \hline
         7 &  & 5.539 & --- & --- & --- \\
         \hline
         8 &  & 9.082 & --- & --- & --- \\
         \hline
         9 &  & 10.964 & --- & --- & --- \\
         \hline
         10 &  & 30.142 & --- & --- & --- \\ [1ex]
         \hline
         \end{tabular}
         \caption{Przykładowe czasy dla wybranych przykładów}
    \end{table}

    \begin{table}[H]
        \centering
         \begin{tabular}{||c | c | c | c | c | c |} 
         \hline
         Przesunięcia & Test1 & Test2 & Test3 & Test4 & Test5 \\ [0.5ex] 
         \hline\hline
         1 & 0.009 & 0.009 & --- & --- & --- \\ 
         \hline
         2 &  & 0.026 & --- & --- & --- \\
         \hline
         3 &  & 0.126 & --- & --- & --- \\
         \hline
         4 &  & 0.519 & --- & --- & --- \\
         \hline
         5 &  & 1.214 & --- & --- & --- \\
         \hline
         6 &  & 1.847 & --- & --- & ---\\ 
         \hline
         7 &  & 5.539 & --- & --- & --- \\
         \hline
         8 &  & 9.082 & --- & --- & --- \\
         \hline
         9 &  & 10.964 & --- & --- & --- \\
         \hline
         10 &  & 30.142 & --- & --- & --- \\ [1ex]
         \hline
         \end{tabular}
         \caption{Przykładowa liczba wnioskowań dla wybranych przykładów}
    \end{table}

    \begin{table}[H]
        \centering
         \begin{tabular}{||c | c | c|} 
         \hline
         Przesunięcia & Wnioskowania & Czas \\ [0.5ex] 
         \hline\hline
         1 &  & 0.009 \\ 
         \hline
         2 &  & 0.026 \\
         \hline
         3 &  & 0.126  \\
         \hline
         4 &  & 0.519  \\
         \hline
         5 &  & 1.214 \\
         \hline
         6 &  & 1.847 \\ 
         \hline
         7 &  & 5.539 \\
         \hline
         8 &  & 9.082 \\
         \hline
         9 &  & 10.964 \\
         \hline
         10 &  & 30.142 \\ [1ex]
         \hline
         \end{tabular}
         \caption{Średnia liczba wnioskowania oraz czasów wykonania}
    \end{table}
    Przez \textit{przesunięcia} należy rozumieć liczbę przesunięć, którą należy wykonać, aby wrócić do początkowego stanu. Dla początkowych wartości 
    wskazanych w tabelach zostało to wyznaczone poprzez ręczne przestawienie kafelków o daną liczbę przesunięc oraz zapisanie otrzymanego stanu 
    przy użyciu nomenklatury opisanej w rozdziale definiujacym świat. Zgodnie z powyższym, analizując przykład \ref{Przyklad15} łatwo zauważyc, 
    iż wymaganą liczbą przesunięc, potrzebną do powrotu do wyjściowego stanu przesuwanki jest liczba \textbf{3} (co w dalszej części udało się 
    udowodnić konstruując odpowiedni plan).



    \subsection{Młodsza siostra- ósemka}
        Ósemka jest inną formą przesuwanki- zamiast tradycyjnego ułożenia 15 klocków w kształcie kwadratu 4 na 4 z jednym wolnym miejscem, w ósemka 
        składa się z osmiu klocków, które ułożone zostały w kształcie kwadratu 3 na 3. Powoduje to zmniejszenie dziedziny, a co za tym idzie- 
        łatwiejsze i szybsze układanie. Dla ósemki wszystkie definicje i własności są identyczne jak dla pietnastki, z drobnym wyjątkiem- dla 
        układanki o osmiu klockach i jednym pustym polu \textbf{boska liczba} wynosi nie 80 a 31\cite{Eight}, oraz liczba możliwych ułożeń wynosi 
        \begin{equation}
            \frac{8!}{2} = 181440
        \end{equation} 
    \subsection{Wyniki dla 8}
        Wersja ze zmniejszoną liczbą klocków została poddana identycznym testom jak piętnastka. Poniżej przedstawione zostały rezultaty 
        przeprowadzonych badania:

        \begin{table}[H]
            \centering
             \begin{tabular}{||c | c | c | c | c | c |} 
             \hline
             Przesunięcia & Test1 & Test2 & Test3 & Test4 & Test5 \\ [0.5ex] 
             \hline\hline
             1 & 0.009 & 0.009 & --- & --- & --- \\ 
             \hline
             2 &  & 0.026 & --- & --- & --- \\
             \hline
             3 &  & 0.126 & --- & --- & --- \\
             \hline
             4 &  & 0.519 & --- & --- & --- \\
             \hline
             5 &  & 1.214 & --- & --- & --- \\
             \hline
             6 &  & 1.847 & --- & --- & ---\\ 
             \hline
             7 &  & 5.539 & --- & --- & --- \\
             \hline
             8 &  & 9.082 & --- & --- & --- \\
             \hline
             9 &  & 10.964 & --- & --- & --- \\
             \hline
             10 &  & 30.142 & --- & --- & --- \\ [1ex]
             \hline
             \end{tabular}
             \caption{Przykładowe czasy dla wybranych przykładów}
        \end{table}
    
        \begin{table}[H]
            \centering
             \begin{tabular}{||c | c | c | c | c | c |} 
             \hline
             Przesunięcia & Test1 & Test2 & Test3 & Test4 & Test5 \\ [0.5ex] 
             \hline\hline
             1 & 0.009 & 0.009 & --- & --- & --- \\ 
             \hline
             2 &  & 0.026 & --- & --- & --- \\
             \hline
             3 &  & 0.126 & --- & --- & --- \\
             \hline
             4 &  & 0.519 & --- & --- & --- \\
             \hline
             5 &  & 1.214 & --- & --- & --- \\
             \hline
             6 &  & 1.847 & --- & --- & ---\\ 
             \hline
             7 &  & 5.539 & --- & --- & --- \\
             \hline
             8 &  & 9.082 & --- & --- & --- \\
             \hline
             9 &  & 10.964 & --- & --- & --- \\
             \hline
             10 &  & 30.142 & --- & --- & --- \\ [1ex]
             \hline
             \end{tabular}
             \caption{Przykładowa liczba wnioskowań dla wybranych przykładów}
        \end{table}
    
        \begin{table}[H]
            \centering
             \begin{tabular}{||c | c | c|} 
             \hline
             Przesunięcia & Wnioskowania & Czas \\ [0.5ex] 
             \hline\hline
             1 &  & 0.009 \\ 
             \hline
             2 &  & 0.026 \\
             \hline
             3 &  & 0.126  \\
             \hline
             4 &  & 0.519  \\
             \hline
             5 &  & 1.214 \\
             \hline
             6 &  & 1.847 \\ 
             \hline
             7 &  & 5.539 \\
             \hline
             8 &  & 9.082 \\
             \hline
             9 &  & 10.964 \\
             \hline
             10 &  & 30.142 \\ [1ex]
             \hline
             \end{tabular}
             \caption{Średnia liczba wnioskowania oraz czasów wykonania}
        \end{table}

    \subsection{Wnioski}
        Dla zdefiniowanego świata GRAPHPLAN poprawnie generuje plany. Empiryczne sprawdzenie wykazało, iż faktycznie są to plany optymalne. Ponadto 
        dla mniejszych przykladów generowanie planów trwa stosunkowo krótko, jednakże w sytuacji, gdy dojdzie do spłaszczenia grafu planującego, 
        co dla przesuwanki z 15 klockami dzieje się w okolicach 10 iteracji, wydajność algorytmu znacznie spada. Podobne efekty zostały 
        zaobserwowane dla układanki z 8 klockami. Porównanie z specjalnie utworzonymi na potrzeby układanki heurstykami pokazały, iż są one 
        znacząco szybsze niż algorytm planujący, jednakże duża zaletą GRAPHPLAN'u jest uniwersalność, gdyż można go stosować do innych problemów,
        heurstyki natomiast rozwiązuję problem jedynie dla danej układanki.
\section{CargoBot}
\label{CargoBotTest}
    \subsection{Wprowadzenie}
        \textbf{CargoBOT} (Twórcy: \textbf{Two Lives Left}) jest grą dostępną w platformie dystrybucji cyfrowej o nazwie \textbf{App Store}, \
        która znajduje się na urządzeniach wyprodukowanych przez firmę \textbf{Apple}. 
        Głównym celem gry jest przestawienie skrzynek z pozycji początkowej na przedstawioną 
        pozycję końcową przy użyciu ramienia, które może poruszać się w prawo, w lewo oraz opuszczać na dół. Podczas opuszczania, jeśli w 
        ramieniu znajduje się skrzynka to zostanie opuszczona, natomiast jeśli ramię nie trzyma żadnej skrzynki podniesie pierwszą na jaką 
        natrafi. Przypatrując się bliżej powyższemu opisowi, nie sposób nie zauważyć połączenia przedstawionego świata z językiem opisowym 
        STRIPS. Z tego powodu kolejnym testem możliwości GRAPHPLAN'u będzie rozwiązywanie zagadek przedstawionych przez aplikację \textbf{CargoBOT}.
        \textbf{UWAGA: } W grze CargoBOT celem użytkownika jest zaprojektowanie algorytmu przy pomocy specjalnego panelu do rozwiązywania łamigłówki.
        Ze względu na to, iż celem testu jest przedstawienie optymalnego planu otrzymującego stan końcowy ze stanu początkowego, wynik algorytmu 
        nie będzie bezpośrednio rozwiązaniem korzystającym z nomenklatury aplikacji.
    \subsection{Szczegóły implementacyjne}
    Przed rozpoczęciem generowania planu, podobnie jak w przypadku poprzednich testów, należy rozpocząć modelowanie świata zgodnie z wytycznymi 
    języka opisu STRIPS. Pierwsze zaimplementowane predykaty to $block/1$ oraz $place/1$. Fakt $block(a)$ oznacza skrzynkę z etykietą a, natomiast 
    $place(1)$ oznacza miejsce z etykietą 1. Ze względu na ograniczenia językowe, każdy z bloków oraz każde z miejsc musi mieć unikatową etykietę. 
    Spowoduje to, iż nie wszystkie łamigłówki z aplikacji będą możliwe do reprodukcji ze względu na to, iż paczki w grze rozróżnialne są od siebie 
    jedynie ze względu na \textit{kolor}. Dodatkowo przez pojęcie miejsca rozumie się przestrzeń, na której może leżeć bloczek. Miejsca można
    wyobrażać sobie jakie półki, bądź platformy, które są od siebie odzielone pewną przeszkodą bądź wolną przestrzenią. Przykład \ref{CargoObrazek}
    przedstawia reprezetancję miejsc w formie czerwonych platform. 
    
    To co odróżnia opis świata dla aplikacji CargoBOT od przesuwanki to fakt, iż liczba skrzynek oraz platform może zmieniać się dynamicznie w zależności 
    od świata. Z tego powodu za każdym razem należy upewnić się, iż wszystkie obiekty zostały opisane w języku algorytmu przy pomocy wyżej przedstawionych 
    predykatów. 

    Jedyną akcją rozpatrywaną jest przesuwanie przy użyciu ramienia skrzynki z jednej platformy na drugą. Akcja ta będzie nazwana identycznie jak w 
    przypadku przesuwanki przy pomocy czasownika $idz$. Trójargumentowa relacja $idz(S,A,B)$ oznacza przesunięcie skrzynki $S$ z platformy $A$
    na platformę $B$. Poniżej przedstawiono implementację warunków zajścia jak i efektów przedstawionej akcji:

    \begin{listing}[H]
        \begin{minted}{prolog}
            %preconditions(+Action,-States)
            preconditions(zostan(P),[P]).

            preconditions(idz(Block,From,To), [pusty(Block),pusty(To),na(Block,From)]) :-
                block(Block),
                object(To),
                To \==Block,
                object(From),
                From \==To,
                Block \== From.
        \end{minted}
    \caption{Implementacja predykatu preconditions/2 dla CargoBOT'a}
    \end{listing}

    \begin{listing}[H]
        \begin{minted}{prolog}
            %effects(+Action,-States)
            effects(zostan(P),[P]).

            effects(idz(X,From,To),[na(X,To),pusty(From),~na(X,From),~pusty(To)]).
        \end{minted}
    \caption{Implementacja predykatu effects/2 CargoBOT'a}
    \end{listing}
    W przypadku akcji przesunięcia warto zaznaczyć, iż może zaistnieć sytuacja, w której najlepszą drogą uzyskania stanu końcowego jest 
    umieszczenie jednej paczki na drugiej. Stąd znane już czytelnikowi predykaty $na/2$ oraz $pusty/1$ w tym przypadku będą się odnosić do skrzynek, 
    ale również do platform. Przyglądając się ciele predykatu $preconditions/2$ należy zauważyć, iż dochodzi do sprawdzenia, czy 
    to co znajduje się w zmiennej $Block$ jest na pewno typu block, oraz czy zmienne $From$ oraz $To$ są obiektami świata. 
    Predykat $object/1$ realizowany jest w następujący sposób:

    \begin{listing}[H]
        \begin{minted}{prolog}
            %object(+Variable)
            object(X) :-
                place(X)
                ;
                block(X).
        \end{minted}
    \caption{Implementacja predykatu object/1}
    \end{listing}

    Zgodnie z powyższą definicją platformy również są obiektami, dlatego należy dokonać dodatkowego sprawdzenia, aby uniemożliwić powstanie 
    takich anomalii jak umieszczanie całej platformy na jednej ze skrzynek.

    Dodatkowe sprawdzenia wykonywane w ramach warunków zajścią mają za zadanie uniknięcie sytuacji, w której planer chciałbym przenieść skrzynkę 
    na samą siebie.
    Implementacja relacji wzajemnie wykluczającej odbyła się w sposób identyczny jak dla 15. Użyty został predykat $inconsistent/2$.
    W powyższy sposób ukończono implementację świata z gry CargoBOT.

    \subsection{Przykład}  
    Celem algorytmu będzie rozwiązanie następującego problemu:
    \begin{figure}[H]
        \label{CargoObrazek}
        \includegraphics[scale=0.35]{cargoBOT_przyklad}
        \centering
        \caption{Przykładowa łamigłówka, źródło zdjęcia: \url{https://i4ds.github.io/CargoBot/?state=3}[ostatni dostęp:06.12.2022]}
    \end{figure}
    Sytuacja ta została odzworowana w aplikacji graficznej w następujący sposób:
    \begin{figure}[H]
        \label{CargoObrazek}
        \includegraphics[scale=0.35]{cargo_przyklad1}
        \centering
        \caption{Reprezentacja łamigłówki w aplikacji}
    \end{figure}
    Po naciśnięciu przycisku \textit{Wygeneruj graf} widok zmienia się w następujący sposób:
    \begin{figure}[H]
        \label{CargoObrazek}
        \includegraphics[scale=0.4]{cargo_przyklad2}
        \centering
        \caption{Rozwiązanie w formie listy kroków zaprezentowane w aplikacji}
    \end{figure}
    Poniżej zamieszczono wygenerowany graf prosty dla rozpatrywanego przypadku:
    \begin{figure}[H]
        \label{CargoObrazek}
        \includegraphics[scale=0.25]{cargo_przyklad1_graf}
        \centering
        \caption{Reprezentacja łamigłówki w aplikacji}
    \end{figure}
    \subsection{Wyniki}
    \subsection{Wnioski}
\section{Przemieszczanie w przestrzeni}
    \subsection{Wprowadzenie}
    \subsection{Przykład}
    \subsection{Szczegóły implementacyjne}
    \subsection{Wyniki}
    \subsection{Wnioski}
\section{Wieża Hanoi}
    \subsection{Wprowadzenie}
    \subsection{Przykład}
    \subsection{Szczegóły implementacyjne}
    \subsection{Wyniki}
    \subsection{Wnioski}
\section{Osiem Hetmanów}
\label{OsiemHetmanowTest}
    \subsection{Wprowadzenie}
    \subsection{Przykład}
    \subsection{Szczegóły implementacyjne}
    \subsection{Wyniki}
    \subsection{Wnioski}